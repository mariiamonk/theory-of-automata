//
// ex: set ro:
// DO NOT EDIT.
// generated by smc (http://smc.sourceforge.net/)
// from file : AppClass.sm
//

#include "AppClass.h"
#include "AppClass_sm.h"

using namespace statemap;

// Static class declarations.
Map1_Start Map1::Start("Map1::Start", 0);
Map1_Name Map1::Name("Map1::Name", 1);
Map1_Zone Map1::Zone("Map1::Zone", 2);
Map1_OK Map1::OK("Map1::OK", 3);
Map1_Error Map1::Error("Map1::Error", 4);

void AppClassState::Dot(AppClassContext& context)
{
    Default(context);
}

void AppClassState::EOS(AppClassContext& context)
{
    Default(context);
}

void AppClassState::Error(AppClassContext& context)
{
    Default(context);
}

void AppClassState::Reset(AppClassContext& context)
{
    Default(context);
}

void AppClassState::Symbol(AppClassContext& context, char sym)
{
    Default(context);
}

void AppClassState::Unknown(AppClassContext& context)
{
    Default(context);
}

void AppClassState::Default(AppClassContext& context)
{
    throw (
        TransitionUndefinedException(
            (context.getState()).getName(),
            context.getTransition()));

}

void Map1_Default::Unknown(AppClassContext& context)
{

    context.getState().Exit(context);
    context.setState(Map1::Error);
    context.getState().Entry(context);


}

void Map1_Default::Reset(AppClassContext& context)
{

    context.getState().Exit(context);
    context.setState(Map1::Start);
    context.getState().Entry(context);


}

void Map1_Start::Entry(AppClassContext& context)

{
    AppClass& ctxt = context.getOwner();

    ctxt.clearString();
}

void Map1_Start::Error(AppClassContext& context)
{
    AppClass& ctxt = context.getOwner();

    context.getState().Exit(context);
    context.clearState();
    try
    {
        ctxt.Unacceptable();
        context.setState(Map1::Error);
    }
    catch (...)
    {
        context.setState(Map1::Error);
        throw;
    }
    context.getState().Entry(context);


}

void Map1_Start::Symbol(AppClassContext& context, char sym)
{
    AppClass& ctxt = context.getOwner();

    if (isCorrectSym())
    {
        AppClassState& endState = context.getState();

        context.clearState();
        try
        {
            ctxt.addSym(Symbol);
            context.setState(endState);
        }
        catch (...)
        {
            context.setState(endState);
            throw;
        }
    }
    else if (isHTTPorWWW())

    {
        context.getState().Exit(context);
        context.clearState();
        try
        {
            ctxt.clearString();
            context.setState(Map1::Name);
        }
        catch (...)
        {
            context.setState(Map1::Name);
            throw;
        }
        context.getState().Entry(context);
    }    else
    {
         Map1_Default::Symbol(context, sym);
    }


}

void Map1_Name::Dot(AppClassContext& context)
{
    AppClass& ctxt = context.getOwner();

    if (isCorrectNameLenth() && isFirstName())
    {
        AppClassState& endState = context.getState();

        context.clearState();
        try
        {
            ctxt.clearString();
            context.setState(endState);
        }
        catch (...)
        {
            context.setState(endState);
            throw;
        }
    }
    else if (isCorrectNameLenth())

    {
        context.getState().Exit(context);
        context.clearState();
        try
        {
            ctxt.clearString();
            context.setState(Map1::Zone);
        }
        catch (...)
        {
            context.setState(Map1::Zone);
            throw;
        }
        context.getState().Entry(context);
    }    else
    {
         Map1_Default::Dot(context);
    }


}

void Map1_Name::Error(AppClassContext& context)
{
    AppClass& ctxt = context.getOwner();

    context.getState().Exit(context);
    context.clearState();
    try
    {
        ctxt.Unacceptable();
        context.setState(Map1::Error);
    }
    catch (...)
    {
        context.setState(Map1::Error);
        throw;
    }
    context.getState().Entry(context);


}

void Map1_Name::Symbol(AppClassContext& context, char sym)
{
    AppClass& ctxt = context.getOwner();

    if (isCorrectSym() && isCorrectNameLenth())
    {
        AppClassState& endState = context.getState();

        context.clearState();
        try
        {
            ctxt.addSym(Symbol);
            context.setState(endState);
        }
        catch (...)
        {
            context.setState(endState);
            throw;
        }
    }
    else
    {
         Map1_Default::Symbol(context, sym);
    }


}

void Map1_Zone::EOS(AppClassContext& context)
{
    AppClass& ctxt = context.getOwner();

    context.getState().Exit(context);
    context.clearState();
    try
    {
        ctxt.Acceptable();
        context.setState(Map1::OK);
    }
    catch (...)
    {
        context.setState(Map1::OK);
        throw;
    }
    context.getState().Entry(context);


}

void Map1_Zone::Error(AppClassContext& context)
{
    AppClass& ctxt = context.getOwner();

    context.getState().Exit(context);
    context.clearState();
    try
    {
        ctxt.Unacceptable();
        context.setState(Map1::Error);
    }
    catch (...)
    {
        context.setState(Map1::Error);
        throw;
    }
    context.getState().Entry(context);


}

void Map1_Zone::Symbol(AppClassContext& context, char sym)
{
    AppClass& ctxt = context.getOwner();

    if (isCorrectSym() && isCorrectZoneLenth())
    {
        AppClassState& endState = context.getState();

        context.clearState();
        try
        {
            ctxt.addSym(Symbol);
            context.setState(endState);
        }
        catch (...)
        {
            context.setState(endState);
            throw;
        }
    }
    else
    {
         Map1_Default::Symbol(context, sym);
    }


}

void Map1_Error::Symbol(AppClassContext& context, char sym)
{



}

//
// Local variables:
//  buffer-read-only: t
// End:
//
